# Division into three Core Elements

Early on, we decided to divide the project into three distinct parts. The rationale behind this separation was that it would help keep our work more organized and focused. In hindsight, this decision has proven valuable, allowing us to address specific issues through targeted debugging without impacting other parts of the application. With each component isolated, problems in one area don't affect the accessibility of others, providing clarity and making testing more efficient and manageable. This modular approach has greatly improved our workflow and overall development process. 

## The three Parts
Based on this reasoning, we decided to split the frontend, backend, and design processes into distinct categories, as outlined below:

### Clients
The clients are the main users of MeetMate. They discover companies, book appointments and use their time schedule. These sorts of tasks can be found in every part of the development team, be it the fetching of upcomming appointments in the backend, {FRONTEND}, {DESIGN} (something that happens in the next section).

This example demonstrates the API endpoint `/api/user/relevantAppointments`, which allows a client to fetch their upcoming appointments. Utilizing the access token system allows us to retrieve all necessary data without requiring additional values, conserving bandwith both for the user and also our servers. After retrieving the requested data from the database, the API responds with a specific HTTP response."
```java
@GetMapping(path = "relevantAppointments")
@ResponseBody
public ResponseEntity<?> getRelevantAppointments(
  @RequestHeader(name = "Authorization") String token){ //Extracting the access token from the request headers
  token = token.substring(7); //Removing the "Bearer: " prefix from the access token 
  try {
    return ResponseEntity.ok(userService.getRelevantAppointments(token));
  } catch (Throwable t) {
    Class<? extends Throwable> tc = t.getClass(); //Getting the type of error
    //Responding with a fitting HTTP code
    if (tc == EntityNotFoundException.class)
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body("message: " + t.getMessage());
  
    if (tc == IllegalAccessException.class)
      return ResponseEntity.status(HttpStatus.FORBIDDEN).body("message: " + t.getMessage());
    //Fallback if an unknown error happens
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
      .body("message: " + t.getMessage());
  }
}
```

Here the {FRONTEND}...

and continue to {DESIGN}... (I'd think that its maybe a the design of the calendar, upcoming appointments or just the dashboard)

### Companies
While company members are not all that different from clients, the companies they belong to require significantly more functionality. Companies need robust features to manage their profiles such as handling administrative tasks such as scheduling appointments or tracking performance metrics. Additionally, companies often interact with multiple users and datasets, necessitating a scalable structure to manage these relationships efficiently. By catering to these additional needs, we ensure a seamless and efficient experience for both individual users and the companies they represent.

In the frontend we are seperating clients and companies through {FRONTEND} (middleware role based access, different dashboards for each, additional sites for companies or similar things i'd recommend on putting here)

These aspects are complemented with a design tailored to the specific needs of each party. {DESIGN} (show of aspects mentioned in the frontend part before this or display your own decisions)


The backend follows the same approach, allocating an entirely new set of management classes and a separate database for this entity. The significant data loads generated by companies - especially when fetching all appointments for their clients - required a shift from the PostgreSQL database, used for clients, to a faster, read-optimized, non-relational MongoDB database. This transition ensures better performance and scalability for handling high-volume queries efficiently. An instance of reading large datasets occurs during the fetching of all clients that are dealing with a company. 
```java
public ArrayList<GetResponse> getClients(String token) throws IllegalAccessException {
  String email = jwtService.extractUserEmail(token);
  //Getting the user and their associated company
  User companyMember = userRepository.findUserByEmail(email)
    .orElseThrow(() -> new EntityNotFoundException("User not found!"));

  Company company = companyRepository.findCompanyById(companyMember.getAssociatedCompany())
    .orElseThrow(() -> new EntityNotFoundException("Company not found"));
  //Checking if the user retrieving the client information is a member of the company
  if (isNotCompanyOwner(email)
    && isNotCompanyMember(company, userRepository.findUserByEmail(email)
      .orElseThrow(() -> new EntityNotFoundException("User not found!"))
      .getId()))
    throw new IllegalAccessException("Not a company member");

  ArrayList<Appointment> appointments = appointmentRepository.findAppointmentsByCompanyId(company.getId());
  ArrayList<User> clients = new ArrayList<>();

  //Constructing the list of clients
  User client;
  for (Appointment appointment : appointments) {
    client = userRepository.findUserById(appointment.getClientId()).orElse(null);
    if (clients.contains(client)) continue;
    clients.add(client);
  }

  //Retrieving data of the clients
  ArrayList<GetResponse> response = new ArrayList<>();
  for (User user : clients) {
    response.add(GetResponse.builder()
      .id(user.getId())
      .name(user.getName())
      .email(user.getEmail())
      .build());
  }

  return response;
}
```
This example is particularly resource-intensive, as it involves not only searching through every appointment to identify those associated with the company but also fetching each client’s details to include in the response. These multiple iterative processes demand a robust and efficient system to handle the complexity without compromising performance. To address this, we employ optimized database queries and caching mechanisms to minimize redundant operations and reduce processing time.

### Appointments

The third pillar of MeetMate are the appointments, the primary idea behind the whole project. At first glance, however, they might seem less prominent than one would expect. This is because their value is derived from the integration with the other components, where they play a central role in linking users, companies, and various data points. The appointments integrate seamlessly with user profiles and company data, pulling relevant information from each to create a smooth, cohesive experience. We ensure that appointments are not just standalone entities but rather dynamic components that evolve with the system’s broader functionality, enabling better organization and user interaction. 

Following the concern of high amounts of records the backend has to consider queries carefully, supporting the performance with faster fetching alongside the MongoDB database and optimised queries through GraphQL. To address the significant amount of data transferred between the server and the user, it's crucial to implement query restrictions that minimize the data sent A prime example for this is the fetching of available appointments for a company, where only relevant data is retrieved, ensuring efficiency and reducing unnecessary overhead.

```java
public ArrayList<Appointment> getAvailableAppointments(long id, Instant date) {
    ArrayList<Appointment> appointments = appointmentRepository.findAppointmentsByCompanyId(id);
    ArrayList<Appointment> availableAppointments = new ArrayList<>();

    // Get start of current day
    LocalDate today = LocalDate.now(ZoneId.systemDefault());
    Instant startOfToday = today.atStartOfDay(ZoneId.systemDefault()).toInstant();

    for (Appointment appointment : appointments) {
      Instant appointmentTime = appointment.getFrom();
      //Considering the case where no date is given the API will output all available appointments
      //Else it filters out all days appointments not on the specified day
      boolean isSameDay = date == null ||
          LocalDate.ofInstant(date, ZoneId.systemDefault())
              .equals(LocalDate.ofInstant(appointmentTime, ZoneId.systemDefault()));

      if (appointment.getStatus() == AppointmentStatus.PENDING
          && appointmentTime.isAfter(startOfToday)  // Compare with start of day instead
          && isSameDay)
        availableAppointments.add(appointment);
    }
    return availableAppointments;
  }
```

This reduced data load benefits the frontend by having the filtering process handled in the backend, which is optimized for such tasks, rather than burdening the frontend with filtering responsibilities. The frontend's primary role is to display the records to the user, not to manage complex data processing, therefore it uses the appointment data given to {FRONTEND} (Maybe show the site that includes fetching the available appointments as shown in the backend or feel free to use a more fitting example)